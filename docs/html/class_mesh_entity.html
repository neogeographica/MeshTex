<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MeshTex: MeshEntity Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeshTex
   &#160;<span id="projectnumber">3.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_mesh_entity.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">MeshEntity Class Reference<div class="ingroups"><a class="el" href="group__meshtex-core.html">MeshTex Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper for a biquadratic Bezier patch mesh entity from Radiant.  
 <a href="class_mesh_entity.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_mesh_entity_8h_source.html">MeshEntity.h</a>&gt;</code></p>

<p><a href="class_mesh_entity-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mesh_entity_1_1_general_function_factors.html">GeneralFunctionFactors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for defining how to manipulate control point or surface values according to some linear combination of various values.  <a href="struct_mesh_entity_1_1_general_function_factors.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for choosing a reference slice of a known kind (row or column) and indicating how to use it for reference.  <a href="struct_mesh_entity_1_1_ref_slice_descriptor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html">RefSliceDescriptorInt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for internal representation of a reference slice of a given kind (row or column), specifying the slice and indicating how to use it for reference.  <a href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for choosing a particular slice of a known kind (row or column).  <a href="struct_mesh_entity_1_1_slice_designation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for orienting a slice within a particular patch.  <a href="struct_mesh_entity_1_1_slice_patch_context.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mesh_entity_1_1_slice_tex_info.html">SliceTexInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for describing the application of a texture along a given slice, on a specified texture axis.  <a href="struct_mesh_entity_1_1_slice_tex_info.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity_1_1_tex_info_callback_method.html">TexInfoCallbackMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of this class can be used as a <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da" title="Type for texture scale info callbacks.">MeshEntity::TexInfoCallback</a>, in situations where the callback is a method to be invoked on a target object.  <a href="class_mesh_entity_1_1_tex_info_callback_method.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8a1e03cfd001377dc03892eeb00d417d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a> { <a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417daf91db02b65159ff0636f3c8ac9838c19">S_TEX_AXIS_ONLY</a>, 
<a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417da034ec25f41e2d797cced769f1e95acd1">T_TEX_AXIS_ONLY</a>, 
<a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417dadb81da86898f798a4a2fa5d2a4c2e69a">ALL_TEX_AXES</a>
 }</td></tr>
<tr class="memdesc:a8a1e03cfd001377dc03892eeb00d417d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent the texture axes an operation should manipulate.  <a href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">More...</a><br/></td></tr>
<tr class="memitem:a685db39c1285bba9739943a195af2a4b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> { <a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba0620784aae5a5f10a44a36d18111cb40">ROW_SLICE_TYPE</a> =  0, 
<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba9bc5d39f0658ed24bd36c5cf1e3fb829">COL_SLICE_TYPE</a> =  1, 
<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a> =  2
 }</td></tr>
<tr class="memdesc:a685db39c1285bba9739943a195af2a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent the kinds of patch mesh slices.  <a href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">More...</a><br/></td></tr>
<tr class="memitem:ab24d5b2cb47e9a0c43f2779163bf41d7"><td class="memItemLeft" align="right" valign="top">typedef Callback1&lt; const char <br class="typebreak"/>
*, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a></td></tr>
<tr class="memdesc:ab24d5b2cb47e9a0c43f2779163bf41d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for info/warning/error callbacks.  <a href="#ab24d5b2cb47e9a0c43f2779163bf41d7"></a><br/></td></tr>
<tr class="memitem:aaa480edbad87f2abae398177cbfdd3da"><td class="memItemLeft" align="right" valign="top">typedef Callback2&lt; float, <br class="typebreak"/>
float, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">TexInfoCallback</a></td></tr>
<tr class="memdesc:aaa480edbad87f2abae398177cbfdd3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for texture scale info callbacks.  <a href="#aaa480edbad87f2abae398177cbfdd3da"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Lifecycle</div></td></tr>
<tr class="memitem:a979fa01397bb8d0c403fce7ca09afd48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a979fa01397bb8d0c403fce7ca09afd48">MeshEntity</a> (scene::Node &amp;mesh, const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a> &amp;infoReportCallback, const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a> &amp;warningReportCallback, const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a> &amp;errorReportCallback)</td></tr>
<tr class="memdesc:a979fa01397bb8d0c403fce7ca09afd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a979fa01397bb8d0c403fce7ca09afd48"></a><br/></td></tr>
<tr class="memitem:ab9c2f1f40c9d07234a201b5925bea928"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ab9c2f1f40c9d07234a201b5925bea928">~MeshEntity</a> ()</td></tr>
<tr class="memdesc:ab9c2f1f40c9d07234a201b5925bea928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab9c2f1f40c9d07234a201b5925bea928"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Interrogation</div></td></tr>
<tr class="memitem:a165923e9726ce3d7ca652345484c75c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a165923e9726ce3d7ca652345484c75c3">IsValid</a> () const </td></tr>
<tr class="memdesc:a165923e9726ce3d7ca652345484c75c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the patch mesh is valid, in the characteristics that this wrapper class cares about.  <a href="#a165923e9726ce3d7ca652345484c75c3"></a><br/></td></tr>
<tr class="memitem:a41b3e774ea441304112723af05ba32bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a41b3e774ea441304112723af05ba32bb">GetInfo</a> (const int *refRow, const int *refCol, const <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">TexInfoCallback</a> *rowTexInfoCallback, const <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">TexInfoCallback</a> *colTexInfoCallback)</td></tr>
<tr class="memdesc:a41b3e774ea441304112723af05ba32bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the patch mesh.  <a href="#a41b3e774ea441304112723af05ba32bb"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Simple modification</div></td></tr>
<tr class="memitem:aa407428bd1a83f19898f75818fca7fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aa407428bd1a83f19898f75818fca7fdd">MinAlign</a> (<a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a> axes)</td></tr>
<tr class="memdesc:aa407428bd1a83f19898f75818fca7fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the specified texture axes, shift the lowest-valued texture coordinates off of the mesh until an integral texture coordinate (texture boundary) is on the mesh edge.  <a href="#aa407428bd1a83f19898f75818fca7fdd"></a><br/></td></tr>
<tr class="memitem:a1490babf0db191c06d9beb87d5146000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a1490babf0db191c06d9beb87d5146000">MaxAlign</a> (<a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a> axes)</td></tr>
<tr class="memdesc:a1490babf0db191c06d9beb87d5146000"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the specified texture axes, shift the highest-valued texture coordinates off of the mesh until an integral texture coordinate (texture boundary) is on the mesh edge.  <a href="#a1490babf0db191c06d9beb87d5146000"></a><br/></td></tr>
<tr class="memitem:a24e9ff6be5a8e6225bfe5463181df657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a24e9ff6be5a8e6225bfe5463181df657">MinMaxAlignAutoScale</a> (<a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a> axes)</td></tr>
<tr class="memdesc:a24e9ff6be5a8e6225bfe5463181df657"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the specified texture axes, perform either MinMaxAlignStretch or MinMaxAlignShrink; the chosen operation will be the one with the least absolute change in the value of the texture scale.  <a href="#a24e9ff6be5a8e6225bfe5463181df657"></a><br/></td></tr>
<tr class="memitem:a1e1c37e60513dda11247c67e1399eace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a1e1c37e60513dda11247c67e1399eace">MinMaxAlignStretch</a> (<a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a> axes)</td></tr>
<tr class="memdesc:a1e1c37e60513dda11247c67e1399eace"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the specified texture axes, align a texture boundary to one edge of the mesh, then increase the texture scale to align a texture boundary to the other edge of the mesh as well.  <a href="#a1e1c37e60513dda11247c67e1399eace"></a><br/></td></tr>
<tr class="memitem:af59e4d93833c3efc752bd84138c3f937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#af59e4d93833c3efc752bd84138c3f937">MinMaxAlignShrink</a> (<a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a> axes)</td></tr>
<tr class="memdesc:af59e4d93833c3efc752bd84138c3f937"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the specified texture axes, align a texture boundary to one edge of the mesh, then decrease the texture scale to align a texture boundary to the other edge of the mesh as well.  <a href="#af59e4d93833c3efc752bd84138c3f937"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Complex modification</div></td></tr>
<tr class="memitem:a34f4ecb5a57b9fe3000d2aea335d3ae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a34f4ecb5a57b9fe3000d2aea335d3ae2">SetScale</a> (<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType, const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *alignSlice, const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *refSlice, bool naturalScale, float naturalScaleOrTiles)</td></tr>
<tr class="memdesc:a34f4ecb5a57b9fe3000d2aea335d3ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the texture scaling along the rows or columns of the mesh.  <a href="#a34f4ecb5a57b9fe3000d2aea335d3ae2"></a><br/></td></tr>
<tr class="memitem:acd5d931d4bc99c641583b0cdd4811100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#acd5d931d4bc99c641583b0cdd4811100">GeneralFunction</a> (const <a class="el" href="struct_mesh_entity_1_1_general_function_factors.html">GeneralFunctionFactors</a> *sFactors, const <a class="el" href="struct_mesh_entity_1_1_general_function_factors.html">GeneralFunctionFactors</a> *tFactors, const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *alignRow, const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *alignCol, const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *refRow, const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *refCol, bool surfaceValues)</td></tr>
<tr class="memdesc:acd5d931d4bc99c641583b0cdd4811100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mesh's texture coordinates according to a linear combination of factors.  <a href="#acd5d931d4bc99c641583b0cdd4811100"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a770df881e27ba52fa9382b055fed91d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> { <a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4adabd8078ad6f8b8c5dac6076d3988789">S_TEX_AXIS</a> =  0, 
<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4ac216430e3ab65a92779820ddf6ce78a3">T_TEX_AXIS</a> =  1, 
<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a> =  2
 }</td></tr>
<tr class="memdesc:a770df881e27ba52fa9382b055fed91d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent the kinds of texture axis.  <a href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">More...</a><br/></td></tr>
<tr class="memitem:a10ff31f1728666ccf4796924b18a968f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968f">PositionAxis</a> { <a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968fab45812176e6d39d54d58bbff6dc14019">X_POS_AXIS</a> =  0, 
<a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968facdae81f140abb55be26c1db5535c7377">Y_POS_AXIS</a> =  1, 
<a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968faf7b46a344567b7478468c896a2d694eb">Z_POS_AXIS</a> =  2, 
<a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968fa2ca5af94fa9d9c709978a7dc0a3c6bd1">NUM_POS_AXES</a> =  3
 }</td></tr>
<tr class="memdesc:a10ff31f1728666ccf4796924b18a968f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent the kinds of position (spatial) axis.  <a href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968f">More...</a><br/></td></tr>
<tr class="memitem:a1f04e4e7d62c3e61d972f9d432702fd8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a1f04e4e7d62c3e61d972f9d432702fd8">ScaleOperation</a> { <a class="el" href="class_mesh_entity.html#a1f04e4e7d62c3e61d972f9d432702fd8a63023b8cd2108d01ddc7e64b0ebb3616">STRETCH_SCALE_OP</a>, 
<a class="el" href="class_mesh_entity.html#a1f04e4e7d62c3e61d972f9d432702fd8abe1b12df3124034e37c857304ac3b267">SHRINK_SCALE_OP</a>
 }</td></tr>
<tr class="memdesc:a1f04e4e7d62c3e61d972f9d432702fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values that represent ways of scaling a texture to make it aligned.  <a href="class_mesh_entity.html#a1f04e4e7d62c3e61d972f9d432702fd8">More...</a><br/></td></tr>
<tr class="memitem:a4cda70bb30ce6163756c166f3119e825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cda70bb30ce6163756c166f3119e825"></a>
typedef bool(MeshEntity::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a4cda70bb30ce6163756c166f3119e825">InternalImpl</a> )(<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis)</td></tr>
<tr class="memdesc:a4cda70bb30ce6163756c166f3119e825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature for a private method that applies a preset transformation on a given texture axis. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Unimplemented to prevent copy/assignment</div></td></tr>
<tr class="memitem:a1d2e37cb1da69060d05a985c81df68fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2e37cb1da69060d05a985c81df68fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MeshEntity</b> (const <a class="el" href="class_mesh_entity.html">MeshEntity</a> &amp;)</td></tr>
<tr class="memitem:aa1a227274b4bb2bd93a48c95ff861946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1a227274b4bb2bd93a48c95ff861946"></a>
const <a class="el" href="class_mesh_entity.html">MeshEntity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_mesh_entity.html">MeshEntity</a> &amp;)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal state refresh</div></td></tr>
<tr class="memitem:ae1c62812f2d22353a3703e59b29cfd7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ae1c62812f2d22353a3703e59b29cfd7f">UpdatePosMinMax</a> (<a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968f">PositionAxis</a> axis)</td></tr>
<tr class="memdesc:ae1c62812f2d22353a3703e59b29cfd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the internally stored information for the min and max extent of the mesh on the specified worldspace axis.  <a href="#ae1c62812f2d22353a3703e59b29cfd7f"></a><br/></td></tr>
<tr class="memitem:aae55d0aeb1f98ef94765b7fe7da001f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aae55d0aeb1f98ef94765b7fe7da001f5">UpdateTexMinMax</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis)</td></tr>
<tr class="memdesc:aae55d0aeb1f98ef94765b7fe7da001f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the internally stored information for the min and max extent of the mesh on the specified texture axis.  <a href="#aae55d0aeb1f98ef94765b7fe7da001f5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Radiant state management</div></td></tr>
<tr class="memitem:af6d664cd4935ea61127c6ba2ea7f986b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d664cd4935ea61127c6ba2ea7f986b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#af6d664cd4935ea61127c6ba2ea7f986b">CreateUndoPoint</a> ()</td></tr>
<tr class="memdesc:af6d664cd4935ea61127c6ba2ea7f986b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to the Radiant undo buffer; save the current state of the mesh to allow rollback to this point by an undo operation. <br/></td></tr>
<tr class="memitem:ae0ec59cb794e3f07cf66a5a044f19a1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0ec59cb794e3f07cf66a5a044f19a1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ae0ec59cb794e3f07cf66a5a044f19a1a">CommitChanges</a> ()</td></tr>
<tr class="memdesc:ae0ec59cb794e3f07cf66a5a044f19a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commit the changes to the mesh so that they will be reflected in Radiant. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Argument resolution</div></td></tr>
<tr class="memitem:adedcafa68abb725f7714cb4671155939"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#adedcafa68abb725f7714cb4671155939">InternalSliceDesignation</a> (const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *sliceDesignation, <a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType)</td></tr>
<tr class="memdesc:adedcafa68abb725f7714cb4671155939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from <a class="el" href="struct_mesh_entity_1_1_slice_designation.html" title="Type for choosing a particular slice of a known kind (row or column).">SliceDesignation</a> to a slice number.  <a href="#adedcafa68abb725f7714cb4671155939"></a><br/></td></tr>
<tr class="memitem:a431336f7709167c209e5aa59747c91f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html">RefSliceDescriptorInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a431336f7709167c209e5aa59747c91f6">InternalRefSliceDescriptor</a> (const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *refSlice, <a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType, <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html">RefSliceDescriptorInt</a> &amp;refSliceInt)</td></tr>
<tr class="memdesc:a431336f7709167c209e5aa59747c91f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html" title="Type for choosing a reference slice of a known kind (row or column) and indicating how to use it for ...">RefSliceDescriptor</a> to <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html" title="Type for internal representation of a reference slice of a given kind (row or column), specifying the slice and indicating how to use it for reference.">RefSliceDescriptorInt</a>.  <a href="#a431336f7709167c209e5aa59747c91f6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Subroutines for interrogation</div></td></tr>
<tr class="memitem:a2988c40480ddff98cd519d8d245e537d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a2988c40480ddff98cd519d8d245e537d">GetSliceTexScale</a> (<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType, int slice, <a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, float tiles)</td></tr>
<tr class="memdesc:a2988c40480ddff98cd519d8d245e537d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a slice and a number of times that its texture should tile along it, find the appropriate texture scale.  <a href="#a2988c40480ddff98cd519d8d245e537d"></a><br/></td></tr>
<tr class="memitem:a8643e71a148ecdcece6750e08e6f49fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a8643e71a148ecdcece6750e08e6f49fd">GetSliceTexInfo</a> (<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType, int slice, <a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, <a class="el" href="struct_mesh_entity_1_1_slice_tex_info.html">SliceTexInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a8643e71a148ecdcece6750e08e6f49fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the <a class="el" href="struct_mesh_entity_1_1_slice_tex_info.html" title="Type for describing the application of a texture along a given slice, on a specified texture axis...">SliceTexInfo</a> for the indicated slice and texture axis.  <a href="#a8643e71a148ecdcece6750e08e6f49fd"></a><br/></td></tr>
<tr class="memitem:ab36c7e498cb7d8a2747c299fdc435570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ab36c7e498cb7d8a2747c299fdc435570">ReportSliceTexInfo</a> (<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType, int slice, <a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, char *messageBuffer, unsigned messageBufferSize, const <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">TexInfoCallback</a> *texInfoCallback)</td></tr>
<tr class="memdesc:ab36c7e498cb7d8a2747c299fdc435570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the information from GetSliceTexInfo and sanitize it for reporting.  <a href="#ab36c7e498cb7d8a2747c299fdc435570"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Subroutines for simple modification</div></td></tr>
<tr class="memitem:a6bd2f879948b7fa7807e846682c5474c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a6bd2f879948b7fa7807e846682c5474c">ProcessForAxes</a> (<a class="el" href="class_mesh_entity.html#a4cda70bb30ce6163756c166f3119e825">InternalImpl</a> internalImpl, <a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a> axes)</td></tr>
<tr class="memdesc:a6bd2f879948b7fa7807e846682c5474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply some function with the InternalImpl signature to each of the designated texture axes.  <a href="#a6bd2f879948b7fa7807e846682c5474c"></a><br/></td></tr>
<tr class="memitem:a822a3522b2184c10218e360358dee035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a822a3522b2184c10218e360358dee035">Shift</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, float shift)</td></tr>
<tr class="memdesc:a822a3522b2184c10218e360358dee035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an offset to all control point values for the given texture axis.  <a href="#a822a3522b2184c10218e360358dee035"></a><br/></td></tr>
<tr class="memitem:aca56654f611c0f0ddcc7725b05136891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aca56654f611c0f0ddcc7725b05136891">Scale</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, float scale)</td></tr>
<tr class="memdesc:aca56654f611c0f0ddcc7725b05136891"><td class="mdescLeft">&#160;</td><td class="mdescRight">On the given texture axis, find the distance of all control point values from the current minimum value and multiply that distance by the given scale factor.  <a href="#aca56654f611c0f0ddcc7725b05136891"></a><br/></td></tr>
<tr class="memitem:a1a8f165c82b1217c655ec7607d6fac4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a1a8f165c82b1217c655ec7607d6fac4c">MinAlignInt</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis)</td></tr>
<tr class="memdesc:a1a8f165c82b1217c655ec7607d6fac4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of MinAlign for a single texture axis.  <a href="#a1a8f165c82b1217c655ec7607d6fac4c"></a><br/></td></tr>
<tr class="memitem:a6d0e00cfd11c3e7089052290aa3903a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a6d0e00cfd11c3e7089052290aa3903a6">MaxAlignInt</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis)</td></tr>
<tr class="memdesc:a6d0e00cfd11c3e7089052290aa3903a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of MaxAlign for a single texture axis.  <a href="#a6d0e00cfd11c3e7089052290aa3903a6"></a><br/></td></tr>
<tr class="memitem:a0b14f98e1b8b10cc2dde0af3f50ccbcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a0b14f98e1b8b10cc2dde0af3f50ccbcc">MinMaxAlignAutoScaleInt</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis)</td></tr>
<tr class="memdesc:a0b14f98e1b8b10cc2dde0af3f50ccbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of MinMaxAlignAutoScale for a single texture axis.  <a href="#a0b14f98e1b8b10cc2dde0af3f50ccbcc"></a><br/></td></tr>
<tr class="memitem:a195f49da7e3aa171c4395cf713cf0e55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a195f49da7e3aa171c4395cf713cf0e55">MinMaxAlignScale</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, <a class="el" href="class_mesh_entity.html#a1f04e4e7d62c3e61d972f9d432702fd8">ScaleOperation</a> op)</td></tr>
<tr class="memdesc:a195f49da7e3aa171c4395cf713cf0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The meat of MinMaxAlignStretchInt and MinMaxAlignShrinkInt.  <a href="#a195f49da7e3aa171c4395cf713cf0e55"></a><br/></td></tr>
<tr class="memitem:ad026e839d453c763ee9a08e71a878487"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ad026e839d453c763ee9a08e71a878487">MinMaxAlignStretchInt</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis)</td></tr>
<tr class="memdesc:ad026e839d453c763ee9a08e71a878487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of MinMaxAlignStretch for a single texture axis.  <a href="#ad026e839d453c763ee9a08e71a878487"></a><br/></td></tr>
<tr class="memitem:a0d85570fdf8ce48100bbc5ed37e91e70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a0d85570fdf8ce48100bbc5ed37e91e70">MinMaxAlignShrinkInt</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis)</td></tr>
<tr class="memdesc:a0d85570fdf8ce48100bbc5ed37e91e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of MinMaxAlignShrink for a single texture axis.  <a href="#a0d85570fdf8ce48100bbc5ed37e91e70"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Surface measurement</div></td></tr>
<tr class="memitem:a0298bb1f207b954af0f7b9729e6468d2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a0298bb1f207b954af0f7b9729e6468d2">SliceParametricSpeedComponent</a> (<a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968f">PositionAxis</a> axis, float t, const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;context)</td></tr>
<tr class="memdesc:a0298bb1f207b954af0f7b9729e6468d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the d(x, y, or z)/dt of a patch slice, evaluated at a given t (parameter for the Bezier function, between 0 and 1).  <a href="#a0298bb1f207b954af0f7b9729e6468d2"></a><br/></td></tr>
<tr class="memitem:ad8726880a4ecd88bbdfa7675aa4bc8c0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ad8726880a4ecd88bbdfa7675aa4bc8c0">SliceParametricSpeed</a> (float t, const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;context)</td></tr>
<tr class="memdesc:ad8726880a4ecd88bbdfa7675aa4bc8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rate of change in worldspace units of a patch slice, evaluated at a given t (parameter for the Bezier function, between 0 and 1).  <a href="#ad8726880a4ecd88bbdfa7675aa4bc8c0"></a><br/></td></tr>
<tr class="memitem:a7d0a10de7698a7d21c0743802645a4ad"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a7d0a10de7698a7d21c0743802645a4ad">EstimateSegmentLength</a> (float startPosition, float endPosition, const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;context)</td></tr>
<tr class="memdesc:a7d0a10de7698a7d21c0743802645a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the surface length of a slice segment, using ten point Gauss-Legendre integration of the parametric speed function.  <a href="#a7d0a10de7698a7d21c0743802645a4ad"></a><br/></td></tr>
<tr class="memitem:a32c3704d3ad29fe0780a16dfb7a388b7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a32c3704d3ad29fe0780a16dfb7a388b7">RefineSegmentLength</a> (float startPosition, float endPosition, const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;context, float segmentLengthEstimate, float maxError)</td></tr>
<tr class="memdesc:a32c3704d3ad29fe0780a16dfb7a388b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively improve the estimate of the surface length of a slice segment, by estimating the length of its halves, until the change between estimates is equal to or less than an acceptable error threshold.  <a href="#a32c3704d3ad29fe0780a16dfb7a388b7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Subroutines for complex modification</div></td></tr>
<tr class="memitem:ab4825d3e8e898c9c76b3ce995b5250b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ab4825d3e8e898c9c76b3ce995b5250b4">GenControlTexFromSurface</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, const Matrix&lt; float &gt; &amp;surfaceValues)</td></tr>
<tr class="memdesc:ab4825d3e8e898c9c76b3ce995b5250b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive control point texture coordinates (on a given texture axis) from a set of mesh surface texture coordinates.  <a href="#ab4825d3e8e898c9c76b3ce995b5250b4"></a><br/></td></tr>
<tr class="memitem:a471abc7e45d6eac669695799a73bd68e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a471abc7e45d6eac669695799a73bd68e">CopyControlTexFromValues</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, const Matrix&lt; float &gt; &amp;values)</td></tr>
<tr class="memdesc:a471abc7e45d6eac669695799a73bd68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite control point texture coordinates (on a given texture axis) with the input texture coordinates.  <a href="#a471abc7e45d6eac669695799a73bd68e"></a><br/></td></tr>
<tr class="memitem:a26655bd4d645bab212dc3760e4359938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a26655bd4d645bab212dc3760e4359938">GenSurfaceFromControlTex</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, Matrix&lt; float &gt; &amp;surfaceValues)</td></tr>
<tr class="memdesc:a26655bd4d645bab212dc3760e4359938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive a set of surface texture coordinates (on a given texture axis) from the control point texture coordinates.  <a href="#a26655bd4d645bab212dc3760e4359938"></a><br/></td></tr>
<tr class="memitem:a07fb972024fa7bb0ca4249b1f8338215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a07fb972024fa7bb0ca4249b1f8338215">CopyValuesFromControlTex</a> (<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, Matrix&lt; float &gt; &amp;values)</td></tr>
<tr class="memdesc:a07fb972024fa7bb0ca4249b1f8338215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the control point texture coordinates (on a given texture axis) to the output texture coordinates parameter.  <a href="#a07fb972024fa7bb0ca4249b1f8338215"></a><br/></td></tr>
<tr class="memitem:aea67bf52f3c1c3b7ffa4a3a2ceaef5cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aea67bf52f3c1c3b7ffa4a3a2ceaef5cc">GenScaledDistanceValues</a> (<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType, int alignSlice, const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html">RefSliceDescriptorInt</a> *refSlice, bool rawScale, float rawScaleOrTiles, Matrix&lt; float &gt; &amp;values)</td></tr>
<tr class="memdesc:aea67bf52f3c1c3b7ffa4a3a2ceaef5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of values based on surface slice lengths and some amount of desired scaling or tiling.  <a href="#aea67bf52f3c1c3b7ffa4a3a2ceaef5cc"></a><br/></td></tr>
<tr class="memitem:ac3cffbd51b87072c81693861bb0a32d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ac3cffbd51b87072c81693861bb0a32d8">GeneralFunctionInt</a> (const <a class="el" href="struct_mesh_entity_1_1_general_function_factors.html">GeneralFunctionFactors</a> &amp;factors, <a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a> axis, int alignRow, int alignCol, bool surfaceValues, const Matrix&lt; float &gt; &amp;rowDistances, const Matrix&lt; float &gt; &amp;colDistances)</td></tr>
<tr class="memdesc:ac3cffbd51b87072c81693861bb0a32d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate coordinates for a specified texture axis based on a linear combination of factors.  <a href="#ac3cffbd51b87072c81693861bb0a32d8"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aaf8336c661ce5edfadf91c7f4ba713f1"><td class="memTemplParams" colspan="2">template&lt;typename Element &gt; </td></tr>
<tr class="memitem:aaf8336c661ce5edfadf91c7f4ba713f1"><td class="memTemplItemLeft" align="right" valign="top">static Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aaf8336c661ce5edfadf91c7f4ba713f1">MatrixElement</a> (Matrix&lt; Element &gt; &amp;matrix, <a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a> sliceType, int slice, int index)</td></tr>
<tr class="memdesc:aaf8336c661ce5edfadf91c7f4ba713f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility template function for accessing a matrix element from code that operates on either kind of slice.  <a href="#aaf8336c661ce5edfadf91c7f4ba713f1"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aebb09c1bcd01efa0408f0b2912972cff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebb09c1bcd01efa0408f0b2912972cff"></a>
scene::Node &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aebb09c1bcd01efa0408f0b2912972cff">_mesh</a></td></tr>
<tr class="memdesc:aebb09c1bcd01efa0408f0b2912972cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle for the Node object in Radiant that is the patch mesh entity. <br/></td></tr>
<tr class="memitem:a3067cca013bcb0c241c51be87aa8cfab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3067cca013bcb0c241c51be87aa8cfab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a3067cca013bcb0c241c51be87aa8cfab">_valid</a></td></tr>
<tr class="memdesc:a3067cca013bcb0c241c51be87aa8cfab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate whether this object was properly generated from the supplied entity. <br/></td></tr>
<tr class="memitem:a18199b1bd23e27f592587da72806effe"><td class="memItemLeft" align="right" valign="top">PatchControlMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a18199b1bd23e27f592587da72806effe">_meshData</a></td></tr>
<tr class="memdesc:a18199b1bd23e27f592587da72806effe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The control points of the mesh.  <a href="#a18199b1bd23e27f592587da72806effe"></a><br/></td></tr>
<tr class="memitem:aab562f33facc50a847e6dcae792c5078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab562f33facc50a847e6dcae792c5078"></a>
const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aab562f33facc50a847e6dcae792c5078">_infoReportCallback</a></td></tr>
<tr class="memdesc:aab562f33facc50a847e6dcae792c5078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used to report information about the mesh. <br/></td></tr>
<tr class="memitem:a157d0a38323aadc3c23685a885520789"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a157d0a38323aadc3c23685a885520789"></a>
const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a157d0a38323aadc3c23685a885520789">_warningReportCallback</a></td></tr>
<tr class="memdesc:a157d0a38323aadc3c23685a885520789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used to deliver warning messages. <br/></td></tr>
<tr class="memitem:ae302c9e3beefa2e707af4b01f1b0abfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae302c9e3beefa2e707af4b01f1b0abfc"></a>
const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ae302c9e3beefa2e707af4b01f1b0abfc">_errorReportCallback</a></td></tr>
<tr class="memdesc:ae302c9e3beefa2e707af4b01f1b0abfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used to deliver error messages when operations on the mesh fail. <br/></td></tr>
<tr class="memitem:ad990738da810df3076f05130abc9d8e6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ad990738da810df3076f05130abc9d8e6">_naturalTexUnits</a> [<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a>]</td></tr>
<tr class="memdesc:ad990738da810df3076f05130abc9d8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of grid units that would constitute a "natural" scale along each texture axis, using the mesh's current texture.  <a href="#ad990738da810df3076f05130abc9d8e6"></a><br/></td></tr>
<tr class="memitem:af09e14b82ba2cbd933a69f801e89903c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af09e14b82ba2cbd933a69f801e89903c"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#af09e14b82ba2cbd933a69f801e89903c">_numSlices</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:af09e14b82ba2cbd933a69f801e89903c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of mesh slices of each kind (row or column). <br/></td></tr>
<tr class="memitem:a4086b39691d63ef474d7dfb7962646c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4086b39691d63ef474d7dfb7962646c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a4086b39691d63ef474d7dfb7962646c3">_texMinMaxDirty</a> [<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a>]</td></tr>
<tr class="memdesc:a4086b39691d63ef474d7dfb7962646c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the values for a texture axis have been modified since the last time their min/max/aligned state was calculated. <br/></td></tr>
<tr class="memitem:ae8137c743d7d4d07c8c6e93c9db0ea96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8137c743d7d4d07c8c6e93c9db0ea96"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ae8137c743d7d4d07c8c6e93c9db0ea96">_texMin</a> [<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a>]</td></tr>
<tr class="memdesc:ae8137c743d7d4d07c8c6e93c9db0ea96"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum values, across the entire mesh, for each texture axis. <br/></td></tr>
<tr class="memitem:af5a17ddce0812cbbac10e8b72bb9dc15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5a17ddce0812cbbac10e8b72bb9dc15"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#af5a17ddce0812cbbac10e8b72bb9dc15">_texMax</a> [<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a>]</td></tr>
<tr class="memdesc:af5a17ddce0812cbbac10e8b72bb9dc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum values, across the entire mesh, for each texture axis. <br/></td></tr>
<tr class="memitem:a1a44658c056288f5abc2e294717a98d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a44658c056288f5abc2e294717a98d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a1a44658c056288f5abc2e294717a98d7">_texMinAligned</a> [<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a>]</td></tr>
<tr class="memdesc:a1a44658c056288f5abc2e294717a98d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the minimum value for a texture axis is on a texture boundary. <br/></td></tr>
<tr class="memitem:abf2a867fe27e1bae36e7cfb0b082829d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf2a867fe27e1bae36e7cfb0b082829d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#abf2a867fe27e1bae36e7cfb0b082829d">_texMaxAligned</a> [<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a>]</td></tr>
<tr class="memdesc:abf2a867fe27e1bae36e7cfb0b082829d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the maximum value for a texture axis is on a texture boundary. <br/></td></tr>
<tr class="memitem:a54d50fffef6cd6e4e83fc43350ad6d45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54d50fffef6cd6e4e83fc43350ad6d45"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a54d50fffef6cd6e4e83fc43350ad6d45">_posMin</a> [<a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968fa2ca5af94fa9d9c709978a7dc0a3c6bd1">NUM_POS_AXES</a>]</td></tr>
<tr class="memdesc:a54d50fffef6cd6e4e83fc43350ad6d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum values, across the entire mesh, for each position axis. <br/></td></tr>
<tr class="memitem:aa3005ef1829b489fd17320d80f5894d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3005ef1829b489fd17320d80f5894d6"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aa3005ef1829b489fd17320d80f5894d6">_posMax</a> [<a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968fa2ca5af94fa9d9c709978a7dc0a3c6bd1">NUM_POS_AXES</a>]</td></tr>
<tr class="memdesc:aa3005ef1829b489fd17320d80f5894d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum values, across the entire mesh, for each position axis. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aad85736e545c12e61d48240b7742669e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aad85736e545c12e61d48240b7742669e">_naturalAxis</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:aad85736e545c12e61d48240b7742669e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given slice kind, which texture axis (S or T) normally changes along it.  <a href="#aad85736e545c12e61d48240b7742669e"></a><br/></td></tr>
<tr class="memitem:a653fa8fa0f46f0b6f8afbaf852e7ab7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a653fa8fa0f46f0b6f8afbaf852e7ab7a"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a653fa8fa0f46f0b6f8afbaf852e7ab7a">_radiantScaleInverted</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>] = { false, true }</td></tr>
<tr class="memdesc:a653fa8fa0f46f0b6f8afbaf852e7ab7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given slice kind, whether Radiant's "natural" scale along a texture axis is backwards compared to the progression of the indices of the orthogonal slices. <br/></td></tr>
<tr class="memitem:a8655174e75acc60cda4252254c4c49eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8655174e75acc60cda4252254c4c49eb"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a8655174e75acc60cda4252254c4c49eb">_radiantTilesInverted</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>] = { false, false }</td></tr>
<tr class="memdesc:a8655174e75acc60cda4252254c4c49eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given slice kind, whether Radiant's interpretation of tiling along a texture axis is backwards compared to the progression of the indices of the orthogonal slices. <br/></td></tr>
<tr class="memitem:af4dcc62549882fde3e6e49f533fd3121"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#af4dcc62549882fde3e6e49f533fd3121">_infoSliceFormatString</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:af4dcc62549882fde3e6e49f533fd3121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message format strings for describing texture mapping on a slice.  <a href="#af4dcc62549882fde3e6e49f533fd3121"></a><br/></td></tr>
<tr class="memitem:aabb9b78d7b2a9c6340636c85d69b7c58"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aabb9b78d7b2a9c6340636c85d69b7c58">_infoSliceInfscaleFormatString</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:aabb9b78d7b2a9c6340636c85d69b7c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message format strings for describing texture mapping on a slice in the unusual case where the scale value is infinite.  <a href="#aabb9b78d7b2a9c6340636c85d69b7c58"></a><br/></td></tr>
<tr class="memitem:a0e4ce970735d8cb8e0bb5757e1a060bc"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a0e4ce970735d8cb8e0bb5757e1a060bc">_warningSliceInfscaleFormatString</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:a0e4ce970735d8cb8e0bb5757e1a060bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message format strings for warning that a scale value is infinite and cannot be transferred to the Set S/T Scale dialog.  <a href="#a0e4ce970735d8cb8e0bb5757e1a060bc"></a><br/></td></tr>
<tr class="memitem:aa155a71654ca8111a5c93d5ab36e83a4"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#aa155a71654ca8111a5c93d5ab36e83a4">_errorBadSliceString</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:aa155a71654ca8111a5c93d5ab36e83a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message format strings for an illegal slice number error.  <a href="#aa155a71654ca8111a5c93d5ab36e83a4"></a><br/></td></tr>
<tr class="memitem:ac6a8d1144b2207e722be98a64f3fbe93"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#ac6a8d1144b2207e722be98a64f3fbe93">_errorSliceZeroscaleString</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:ac6a8d1144b2207e722be98a64f3fbe93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message format strings for a scale = 0 error.  <a href="#ac6a8d1144b2207e722be98a64f3fbe93"></a><br/></td></tr>
<tr class="memitem:a523d2f5b6601891ec545528418ec570a"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mesh_entity.html#a523d2f5b6601891ec545528418ec570a">_errorSliceZerotilesString</a> [<a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303">NUM_SLICE_TYPES</a>]</td></tr>
<tr class="memdesc:a523d2f5b6601891ec545528418ec570a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message format strings for a tiles = 0 error.  <a href="#a523d2f5b6601891ec545528418ec570a"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Wrapper for a biquadratic Bezier patch mesh entity from Radiant. </p>
<p>Instantiate this for a given patch mesh, then use the methods to interrogate or modify the mesh. It is intended that this object be instantiated, used, and then discarded before resuming other Radiant operations, as the implementation assumes that several basic mesh characteristics will remain constant for the life of this object. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ab24d5b2cb47e9a0c43f2779163bf41d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Callback1&lt;const char *, void&gt; <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MeshEntity::MessageCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for info/warning/error callbacks. </p>
<p>The callback takes a const char* argument (the message string); it has no return value. </p>

</div>
</div>
<a class="anchor" id="aaa480edbad87f2abae398177cbfdd3da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Callback2&lt;float, float, void&gt; <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">MeshEntity::TexInfoCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for texture scale info callbacks. </p>
<p>The callback takes two float arguments (scale and tiles); it has no return value. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a10ff31f1728666ccf4796924b18a968f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968f">MeshEntity::PositionAxis</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values that represent the kinds of position (spatial) axis. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a10ff31f1728666ccf4796924b18a968fab45812176e6d39d54d58bbff6dc14019"></a>X_POS_AXIS</em>&nbsp;</td><td>
<p>X position axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a10ff31f1728666ccf4796924b18a968facdae81f140abb55be26c1db5535c7377"></a>Y_POS_AXIS</em>&nbsp;</td><td>
<p>Y position axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a10ff31f1728666ccf4796924b18a968faf7b46a344567b7478468c896a2d694eb"></a>Z_POS_AXIS</em>&nbsp;</td><td>
<p>Z position axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a10ff31f1728666ccf4796924b18a968fa2ca5af94fa9d9c709978a7dc0a3c6bd1"></a>NUM_POS_AXES</em>&nbsp;</td><td>
<p>number of kinds of position axis </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f04e4e7d62c3e61d972f9d432702fd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mesh_entity.html#a1f04e4e7d62c3e61d972f9d432702fd8">MeshEntity::ScaleOperation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values that represent ways of scaling a texture to make it aligned. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1f04e4e7d62c3e61d972f9d432702fd8a63023b8cd2108d01ddc7e64b0ebb3616"></a>STRETCH_SCALE_OP</em>&nbsp;</td><td>
<p>scale by stretching </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1f04e4e7d62c3e61d972f9d432702fd8abe1b12df3124034e37c857304ac3b267"></a>SHRINK_SCALE_OP</em>&nbsp;</td><td>
<p>scale by shrinking </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a685db39c1285bba9739943a195af2a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">MeshEntity::SliceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values that represent the kinds of patch mesh slices. </p>
<p>Note that the assigned integer values are significant; do not change. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a685db39c1285bba9739943a195af2a4ba0620784aae5a5f10a44a36d18111cb40"></a>ROW_SLICE_TYPE</em>&nbsp;</td><td>
<p>row </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a685db39c1285bba9739943a195af2a4ba9bc5d39f0658ed24bd36c5cf1e3fb829"></a>COL_SLICE_TYPE</em>&nbsp;</td><td>
<p>column </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a685db39c1285bba9739943a195af2a4ba03adc2f8e84e9ee6f4c507d77286b303"></a>NUM_SLICE_TYPES</em>&nbsp;</td><td>
<p>number of kinds of slice </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a770df881e27ba52fa9382b055fed91d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">MeshEntity::TextureAxis</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values that represent the kinds of texture axis. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a770df881e27ba52fa9382b055fed91d4adabd8078ad6f8b8c5dac6076d3988789"></a>S_TEX_AXIS</em>&nbsp;</td><td>
<p>S texture axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a770df881e27ba52fa9382b055fed91d4ac216430e3ab65a92779820ddf6ce78a3"></a>T_TEX_AXIS</em>&nbsp;</td><td>
<p>T texture axis. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c"></a>NUM_TEX_AXES</em>&nbsp;</td><td>
<p>number of kinds of texture axis </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a1e03cfd001377dc03892eeb00d417d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">MeshEntity::TextureAxisSelection</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values that represent the texture axes an operation should manipulate. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8a1e03cfd001377dc03892eeb00d417daf91db02b65159ff0636f3c8ac9838c19"></a>S_TEX_AXIS_ONLY</em>&nbsp;</td><td>
<p>manipulate the S values </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8a1e03cfd001377dc03892eeb00d417da034ec25f41e2d797cced769f1e95acd1"></a>T_TEX_AXIS_ONLY</em>&nbsp;</td><td>
<p>manipulate the T values </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8a1e03cfd001377dc03892eeb00d417dadb81da86898f798a4a2fa5d2a4c2e69a"></a>ALL_TEX_AXES</em>&nbsp;</td><td>
<p>manipulate both S and T values </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a979fa01397bb8d0c403fce7ca09afd48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshEntity::MeshEntity </td>
          <td>(</td>
          <td class="paramtype">scene::Node &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>infoReportCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>warningReportCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mesh_entity.html#ab24d5b2cb47e9a0c43f2779163bf41d7">MessageCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>errorReportCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>If the constructor is unable to process the input mesh, then the internal valid flag (queryable through IsValid) is set false, and the errorReportCallback is invoked.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The patch mesh to construct a wrapper for. </td></tr>
    <tr><td class="paramname">infoReportCallback</td><td>Callback for future informational messages. </td></tr>
    <tr><td class="paramname">warningReportCallback</td><td>Callback for future warning messages. </td></tr>
    <tr><td class="paramname">errorReportCallback</td><td>Callback for future error messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9c2f1f40c9d07234a201b5925bea928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshEntity::~MeshEntity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that this only destroys the wrapper object, not the patch mesh itself. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a471abc7e45d6eac669695799a73bd68e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::CopyControlTexFromValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite control point texture coordinates (on a given texture axis) with the input texture coordinates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis of interest. </td></tr>
    <tr><td class="paramname">values</td><td>The input texture coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07fb972024fa7bb0ca4249b1f8338215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::CopyValuesFromControlTex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the control point texture coordinates (on a given texture axis) to the output texture coordinates parameter. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">axis</td><td>The texture axis of interest. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The output texture coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d0a10de7698a7d21c0743802645a4ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MeshEntity::EstimateSegmentLength </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the surface length of a slice segment, using ten point Gauss-Legendre integration of the parametric speed function. </p>
<p>The value returned will always be positive (absolute value).</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">startPosition</td><td>Bezier parameter value for the start point of the slice segment. </td></tr>
    <tr><td class="paramname">endPosition</td><td>Bezier parameter value for the end point of the slice segment. </td></tr>
    <tr><td class="paramname">context</td><td>The slice and patch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Estimate of segment length. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4825d3e8e898c9c76b3ce995b5250b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::GenControlTexFromSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfaceValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derive control point texture coordinates (on a given texture axis) from a set of mesh surface texture coordinates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis of interest. </td></tr>
    <tr><td class="paramname">surfaceValues</td><td>The surface texture coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd5d931d4bc99c641583b0cdd4811100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::GeneralFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_general_function_factors.html">GeneralFunctionFactors</a> *&#160;</td>
          <td class="paramname"><em>sFactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_general_function_factors.html">GeneralFunctionFactors</a> *&#160;</td>
          <td class="paramname"><em>tFactors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *&#160;</td>
          <td class="paramname"><em>alignRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *&#160;</td>
          <td class="paramname"><em>alignCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *&#160;</td>
          <td class="paramname"><em>refRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *&#160;</td>
          <td class="paramname"><em>refCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>surfaceValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the mesh's texture coordinates according to a linear combination of factors. </p>
<p>This equation can be used to set the texture coordinates at the control points themselves, or to directly set the texture coordinates at the locations on the mesh surface that correspond to each half-patch interval.</p>
<p>An alignment row is used as the zero-point for any calculations of row number or of distance along a column surface when processing the equation. An alignment column is similarly used. (Note that the number identifying the alignment row/column is the real number used to index into the mesh; it's not the modified number as affected by the alignment column/row when processing the equation. We don't want to be stuck in a chicken-and-egg situation.)</p>
<p>Calculations of distance along row/col surface may optionally be affected by a designated reference row/col. The reference row/col can be used as a source of end-to-end distance only, in which case the proportional spacing of the control points within the affected row/col will determine the distance value to be used for each control point. Or, the distance value for every control point in the reference row/col can be copied to each corresponding control point in the other rows/cols.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sFactors</td><td>Factors to determine the S texture coords; NULL if S axis unaffected. </td></tr>
    <tr><td class="paramname">tFactors</td><td>Factors to determine the T texture coords; NULL if T axis unaffected. </td></tr>
    <tr><td class="paramname">alignRow</td><td>Pointer to zero-point row; if NULL, row 0 is assumed. </td></tr>
    <tr><td class="paramname">alignCol</td><td>Pointer to zero-point column; if NULL, column 0 is assumed. </td></tr>
    <tr><td class="paramname">refRow</td><td>Pointer to reference row description, including how to use the reference; NULL if no reference. </td></tr>
    <tr><td class="paramname">refCol</td><td>Pointer to reference column description, including how to use the reference; NULL if no reference. </td></tr>
    <tr><td class="paramname">surfaceValues</td><td>true if calculations are for S/T values on the mesh surface; false if calculations are for S/T values at the control points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3cffbd51b87072c81693861bb0a32d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::GeneralFunctionInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_general_function_factors.html">GeneralFunctionFactors</a> &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>surfaceValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>rowDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>colDistances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate coordinates for a specified texture axis based on a linear combination of factors. </p>
<p>This method does the final work for the GeneralFunction public method.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">factors</td><td>Factors to determine the texture coords. </td></tr>
    <tr><td class="paramname">axis</td><td>The texture axis to process. </td></tr>
    <tr><td class="paramname">alignRow</td><td>Zero-point row. </td></tr>
    <tr><td class="paramname">alignCol</td><td>Zero-point column. </td></tr>
    <tr><td class="paramname">surfaceValues</td><td>true if calculations are for S/T values on the mesh surface; false if calculations are for S/T values at the control points. </td></tr>
    <tr><td class="paramname">rowDistances</td><td>Surface distance-along-row values (measured from alignment column) for spots corresponding to each control point. </td></tr>
    <tr><td class="paramname">colDistances</td><td>Surface distance-along-column values (measured from alignment row) for spots corresponding to each control point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea67bf52f3c1c3b7ffa4a3a2ceaef5cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::GenScaledDistanceValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html">RefSliceDescriptorInt</a> *&#160;</td>
          <td class="paramname"><em>refSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rawScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rawScaleOrTiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a set of values based on surface slice lengths and some amount of desired scaling or tiling. </p>
<p>This method does a great deal of the work for the SetScale public method; refer to that method's comment header for more details about the alignment slice and reference slice inputs. The main difference from the SetScale input parameters is that the scale/tiles factor has been processed some. It has been flipped if necessary to account for Radiant's internal scale/tiles orientation differing from the sensible external orientation. And natural scaling has been converted to raw scaling, which is the actual desired divisor to get texture coordinates from worldspace lengths.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sliceType</td><td>Process rows or colums. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alignSlice</td><td>Pointer to alignment slice description; if NULL, slice 0 is assumed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">refSlice</td><td>Pointer to reference slice description, including how to use the reference; NULL if no reference. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rawScale</td><td>true if rawScaleOrTiles is a scale factor; false if rawScaleOrTiles is a number of tiles. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rawScaleOrTiles</td><td>Scaling determinant, interpreted according to the rawScale parameter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The generated values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26655bd4d645bab212dc3760e4359938"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::GenSurfaceFromControlTex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfaceValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derive a set of surface texture coordinates (on a given texture axis) from the control point texture coordinates. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">axis</td><td>The texture axis of interest. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surfaceValues</td><td>The surface texture coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41b3e774ea441304112723af05ba32bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::GetInfo </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>refRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>refCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">TexInfoCallback</a> *&#160;</td>
          <td class="paramname"><em>rowTexInfoCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">TexInfoCallback</a> *&#160;</td>
          <td class="paramname"><em>colTexInfoCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the patch mesh. </p>
<p>A message string describing general mesh information (number of rows/cols, min/max texture coords, extent in worldspace) will be composed and sent to the infoReportCallback that was specified when this wrapper object was constructed.</p>
<p>Optionally this method can do additional reporting on a specific "reference row" and "reference column". If a reference row and/or column is specified, then information about the reference slice(s) will be added to the information message. If a reference row/col is specified AND a corresponding row/col TexInfoCallback is specified, then the scale and tiling values for the reference slice will also be passed to the relevant callback.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">refRow</td><td>Pointer to reference row number; NULL if none. </td></tr>
    <tr><td class="paramname">refCol</td><td>Pointer to reference column number; NULL if none. </td></tr>
    <tr><td class="paramname">rowTexInfoCallback</td><td>Pointer to callback for reference row info; NULL if none. </td></tr>
    <tr><td class="paramname">colTexInfoCallback</td><td>Pointer to callback for reference column info; NULL if none. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8643e71a148ecdcece6750e08e6f49fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::GetSliceTexInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mesh_entity_1_1_slice_tex_info.html">SliceTexInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate the <a class="el" href="struct_mesh_entity_1_1_slice_tex_info.html" title="Type for describing the application of a texture along a given slice, on a specified texture axis...">SliceTexInfo</a> for the indicated slice and texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sliceType</td><td>Slice kind (row or column). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">slice</td><td>Slice number, among slices of that kind in mesh. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">axis</td><td>The texture axis of interest. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Information on scale, tiles, and min/max for the specified texture axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true on success, false if slice cannot be processed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2988c40480ddff98cd519d8d245e537d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MeshEntity::GetSliceTexScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a slice and a number of times that its texture should tile along it, find the appropriate texture scale. </p>
<p>This result is determined by the surface length along the slice.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceType</td><td>Slice kind (row or column). </td></tr>
    <tr><td class="paramname">slice</td><td>Slice number, among slices of that kind in mesh. </td></tr>
    <tr><td class="paramname">axis</td><td>The texture axis of interest. </td></tr>
    <tr><td class="paramname">tiles</td><td>Number of times the texture tiles.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The texture scale corresponding to the tiling amount. </dd></dl>

</div>
</div>
<a class="anchor" id="a431336f7709167c209e5aa59747c91f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html">MeshEntity::RefSliceDescriptorInt</a> * MeshEntity::InternalRefSliceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *&#160;</td>
          <td class="paramname"><em>refSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html">RefSliceDescriptorInt</a> &amp;&#160;</td>
          <td class="paramname"><em>refSliceInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html" title="Type for choosing a reference slice of a known kind (row or column) and indicating how to use it for ...">RefSliceDescriptor</a> to <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html" title="Type for internal representation of a reference slice of a given kind (row or column), specifying the slice and indicating how to use it for reference.">RefSliceDescriptorInt</a>. </p>
<p>Interpret max slice if necessary. Populate specified <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html" title="Type for internal representation of a reference slice of a given kind (row or column), specifying the slice and indicating how to use it for reference.">RefSliceDescriptorInt</a> if input is non-NULL and return pointer to it; otherwise return NULL.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">refSlice</td><td>Pointer to reference slice description; may be NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sliceType</td><td>Slice kind (row or column). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">refSliceInt</td><td><a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html" title="Type for internal representation of a reference slice of a given kind (row or column), specifying the slice and indicating how to use it for reference.">RefSliceDescriptorInt</a> to populate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>NULL if input <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html" title="Type for choosing a reference slice of a known kind (row or column) and indicating how to use it for ...">RefSliceDescriptor</a> is NULL; else, pointer to populated <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor_int.html" title="Type for internal representation of a reference slice of a given kind (row or column), specifying the slice and indicating how to use it for reference.">RefSliceDescriptorInt</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="adedcafa68abb725f7714cb4671155939"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MeshEntity::InternalSliceDesignation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *&#160;</td>
          <td class="paramname"><em>sliceDesignation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert from <a class="el" href="struct_mesh_entity_1_1_slice_designation.html" title="Type for choosing a particular slice of a known kind (row or column).">SliceDesignation</a> to a slice number. </p>
<p>Interpret max slice if necessary, and fall back to slice 0 if unspecified.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceDesignation</td><td>Pointer to slice description; may be NULL. </td></tr>
    <tr><td class="paramname">sliceType</td><td>Slice kind (row or column).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The slice number. </dd></dl>

</div>
</div>
<a class="anchor" id="a165923e9726ce3d7ca652345484c75c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if the patch mesh is valid, in the characteristics that this wrapper class cares about. </p>
<p>If not valid then the results of operations on this wrapper object are undefined.</p>
<dl class="section return"><dt>Returns:</dt><dd>true if valid, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf8336c661ce5edfadf91c7f4ba713f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Element &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Element&amp; MeshEntity::MatrixElement </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility template function for accessing a matrix element from code that operates on either kind of slice. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix holding the mesh control points. </td></tr>
    <tr><td class="paramname">sliceType</td><td>Slice kind (row or column). </td></tr>
    <tr><td class="paramname">slice</td><td>Slice number, among slices of that type in mesh. </td></tr>
    <tr><td class="paramname">index</td><td>Element index along the slice.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The matrix element; can be used as lvalue or rvalue. </dd></dl>

</div>
</div>
<a class="anchor" id="a1490babf0db191c06d9beb87d5146000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::MaxAlign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a>&#160;</td>
          <td class="paramname"><em>axes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the specified texture axes, shift the highest-valued texture coordinates off of the mesh until an integral texture coordinate (texture boundary) is on the mesh edge. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>The texture axes to align. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d0e00cfd11c3e7089052290aa3903a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::MaxAlignInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of MaxAlign for a single texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true if the mesh was changed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aa407428bd1a83f19898f75818fca7fdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::MinAlign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a>&#160;</td>
          <td class="paramname"><em>axes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the specified texture axes, shift the lowest-valued texture coordinates off of the mesh until an integral texture coordinate (texture boundary) is on the mesh edge. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>The texture axes to align. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a8f165c82b1217c655ec7607d6fac4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::MinAlignInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of MinAlign for a single texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true if the mesh was changed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a24e9ff6be5a8e6225bfe5463181df657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::MinMaxAlignAutoScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a>&#160;</td>
          <td class="paramname"><em>axes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the specified texture axes, perform either MinMaxAlignStretch or MinMaxAlignShrink; the chosen operation will be the one with the least absolute change in the value of the texture scale. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>The texture axes to align. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b14f98e1b8b10cc2dde0af3f50ccbcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::MinMaxAlignAutoScaleInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of MinMaxAlignAutoScale for a single texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true if the mesh was changed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a195f49da7e3aa171c4395cf713cf0e55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::MinMaxAlignScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a1f04e4e7d62c3e61d972f9d432702fd8">ScaleOperation</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The meat of MinMaxAlignStretchInt and MinMaxAlignShrinkInt. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect. </td></tr>
    <tr><td class="paramname">op</td><td>Whether to stretch or shrink.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true if the mesh was changed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="af59e4d93833c3efc752bd84138c3f937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::MinMaxAlignShrink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a>&#160;</td>
          <td class="paramname"><em>axes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the specified texture axes, align a texture boundary to one edge of the mesh, then decrease the texture scale to align a texture boundary to the other edge of the mesh as well. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>The texture axes to align. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d85570fdf8ce48100bbc5ed37e91e70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::MinMaxAlignShrinkInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of MinMaxAlignShrink for a single texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true if the mesh was changed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e1c37e60513dda11247c67e1399eace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::MinMaxAlignStretch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a>&#160;</td>
          <td class="paramname"><em>axes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the specified texture axes, align a texture boundary to one edge of the mesh, then increase the texture scale to align a texture boundary to the other edge of the mesh as well. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>The texture axes to align. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad026e839d453c763ee9a08e71a878487"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshEntity::MinMaxAlignStretchInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of MinMaxAlignStretch for a single texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true if the mesh was changed, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bd2f879948b7fa7807e846682c5474c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::ProcessForAxes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a4cda70bb30ce6163756c166f3119e825">InternalImpl</a>&#160;</td>
          <td class="paramname"><em>internalImpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a8a1e03cfd001377dc03892eeb00d417d">TextureAxisSelection</a>&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply some function with the InternalImpl signature to each of the designated texture axes. </p>
<p>The undo point and state commit operations are handled here for such functions.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">internalImpl</td><td>The function to apply. </td></tr>
    <tr><td class="paramname">axes</td><td>The texture axes to affect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32c3704d3ad29fe0780a16dfb7a388b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MeshEntity::RefineSegmentLength </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>segmentLengthEstimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively improve the estimate of the surface length of a slice segment, by estimating the length of its halves, until the change between estimates is equal to or less than an acceptable error threshold. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">startPosition</td><td>Bezier parameter value for the start point of the slice segment. </td></tr>
    <tr><td class="paramname">endPosition</td><td>Bezier parameter value for the end point of the slice segment. </td></tr>
    <tr><td class="paramname">context</td><td>The slice and patch. </td></tr>
    <tr><td class="paramname">segmentLengthEstimate</td><td>Starting estimate for segment legnth. </td></tr>
    <tr><td class="paramname">maxError</td><td>Max acceptable variance between estimates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Improved estimate of segment length. </dd></dl>

</div>
</div>
<a class="anchor" id="ab36c7e498cb7d8a2747c299fdc435570"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::ReportSliceTexInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>messageBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>messageBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_mesh_entity.html#aaa480edbad87f2abae398177cbfdd3da">TexInfoCallback</a> *&#160;</td>
          <td class="paramname"><em>texInfoCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the information from GetSliceTexInfo and sanitize it for reporting. </p>
<p>Optionally print to a provided message buffer and/or supply data to a provided TexInfoCallback.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceType</td><td>Slice kind (row or column). </td></tr>
    <tr><td class="paramname">slice</td><td>Slice number, among slices of that kind in mesh. </td></tr>
    <tr><td class="paramname">axis</td><td>The texture axis of interest. </td></tr>
    <tr><td class="paramname">messageBuffer</td><td>Buffer for message data; NULL if none. </td></tr>
    <tr><td class="paramname">messageBufferSize</td><td>Size of the message buffer. </td></tr>
    <tr><td class="paramname">texInfoCallback</td><td>Callback for passing texture scale/tiles info; NULL if none. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca56654f611c0f0ddcc7725b05136891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::Scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On the given texture axis, find the distance of all control point values from the current minimum value and multiply that distance by the given scale factor. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect. </td></tr>
    <tr><td class="paramname">scale</td><td>The scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34f4ecb5a57b9fe3000d2aea335d3ae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::SetScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a685db39c1285bba9739943a195af2a4b">SliceType</a>&#160;</td>
          <td class="paramname"><em>sliceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_designation.html">SliceDesignation</a> *&#160;</td>
          <td class="paramname"><em>alignSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_ref_slice_descriptor.html">RefSliceDescriptor</a> *&#160;</td>
          <td class="paramname"><em>refSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>naturalScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>naturalScaleOrTiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the texture scaling along the rows or columns of the mesh. </p>
<p>This affects only the texture axis that is naturally associated with rows (S) or columns (T) according to the chosen sliceType.</p>
<p>The scaling may be input either as a multiple of the natural scale that Radiant would choose for this texture, or as the number of tiles of the texture that should fit on the mesh's row/column.</p>
<p>Among the slices perpendicular to the direction of scaling, an alignment slice is used to fix the position of the texture boundary.</p>
<p>A reference slice may optionally be chosen among the slices parallel to the scaling direction. If a reference slice is not specified, then the texture coordinates are independently determined for each slice. If a reference slice is specified, its texture coordinates are calculated first and used to affect the other slices. The reference slice's amount of texture tiling will be re-used for all other slices; optionally, the texture coordinate at each control point within the reference slice can be copied to the corresponding control point in every other slice.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceType</td><td>Choose to scale along rows or columns. </td></tr>
    <tr><td class="paramname">alignSlice</td><td>Pointer to alignment slice description; if NULL, slice 0 is assumed. </td></tr>
    <tr><td class="paramname">refSlice</td><td>Pointer to reference slice description, including how to use the reference; NULL if no reference. </td></tr>
    <tr><td class="paramname">naturalScale</td><td>true if naturalScaleOrTiles is a factor of the Radiant natural scale; false if naturalScaleOrTiles is a number of tiles. </td></tr>
    <tr><td class="paramname">naturalScaleOrTiles</td><td>Scaling determinant, interpreted according to the naturalScale parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a822a3522b2184c10218e360358dee035"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::Shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an offset to all control point values for the given texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis to affect. </td></tr>
    <tr><td class="paramname">shift</td><td>The offset to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8726880a4ecd88bbdfa7675aa4bc8c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MeshEntity::SliceParametricSpeed </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the rate of change in worldspace units of a patch slice, evaluated at a given t (parameter for the Bezier function, between 0 and 1). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Bezier parameter. </td></tr>
    <tr><td class="paramname">context</td><td>The slice and patch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>Path length. </dd></dl>

</div>
</div>
<a class="anchor" id="a0298bb1f207b954af0f7b9729e6468d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MeshEntity::SliceParametricSpeedComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968f">PositionAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_mesh_entity_1_1_slice_patch_context.html">SlicePatchContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the d(x, y, or z)/dt of a patch slice, evaluated at a given t (parameter for the Bezier function, between 0 and 1). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The worldspace axis of interest. </td></tr>
    <tr><td class="paramname">t</td><td>Bezier parameter. </td></tr>
    <tr><td class="paramname">context</td><td>The slice and patch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>d(x, y, or z)/dt at the given t. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1c62812f2d22353a3703e59b29cfd7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::UpdatePosMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a10ff31f1728666ccf4796924b18a968f">PositionAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the internally stored information for the min and max extent of the mesh on the specified worldspace axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The worldspace axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae55d0aeb1f98ef94765b7fe7da001f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshEntity::UpdateTexMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">TextureAxis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the internally stored information for the min and max extent of the mesh on the specified texture axis. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The texture axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aa155a71654ca8111a5c93d5ab36e83a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * MeshEntity::_errorBadSliceString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"></div>
<div class="line">   { ERROR_BAD_ROW, ERROR_BAD_COL }</div>
</div><!-- fragment -->
<p>Message format strings for an illegal slice number error. </p>

</div>
</div>
<a class="anchor" id="ac6a8d1144b2207e722be98a64f3fbe93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * MeshEntity::_errorSliceZeroscaleString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"></div>
<div class="line">   { ERROR_ROW_ZEROSCALE, ERROR_COL_ZEROSCALE }</div>
</div><!-- fragment -->
<p>Message format strings for a scale = 0 error. </p>

</div>
</div>
<a class="anchor" id="a523d2f5b6601891ec545528418ec570a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * MeshEntity::_errorSliceZerotilesString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"></div>
<div class="line">   { ERROR_ROW_ZEROTILES, ERROR_COL_ZEROTILES }</div>
</div><!-- fragment -->
<p>Message format strings for a tiles = 0 error. </p>

</div>
</div>
<a class="anchor" id="af4dcc62549882fde3e6e49f533fd3121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * MeshEntity::_infoSliceFormatString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"></div>
<div class="line">   { INFO_ROW_FORMAT, INFO_COL_FORMAT }</div>
</div><!-- fragment -->
<p>Message format strings for describing texture mapping on a slice. </p>

</div>
</div>
<a class="anchor" id="aabb9b78d7b2a9c6340636c85d69b7c58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * MeshEntity::_infoSliceInfscaleFormatString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"></div>
<div class="line">   { INFO_ROW_INFSCALE_FORMAT, INFO_COL_INFSCALE_FORMAT }</div>
</div><!-- fragment -->
<p>Message format strings for describing texture mapping on a slice in the unusual case where the scale value is infinite. </p>

</div>
</div>
<a class="anchor" id="a18199b1bd23e27f592587da72806effe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PatchControlMatrix MeshEntity::_meshData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The control points of the mesh. </p>
<p>Modifying the data in this matrix will modify the mesh entity directly; it is NOT a copy of the entity's data. </p>

</div>
</div>
<a class="anchor" id="aad85736e545c12e61d48240b7742669e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4">MeshEntity::TextureAxis</a> MeshEntity::_naturalAxis</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"></div>
<div class="line">   { <a class="code" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4adabd8078ad6f8b8c5dac6076d3988789" title="S texture axis.">S_TEX_AXIS</a>, <a class="code" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4ac216430e3ab65a92779820ddf6ce78a3" title="T texture axis.">T_TEX_AXIS</a> }</div>
</div><!-- fragment -->
<p>For a given slice kind, which texture axis (S or T) normally changes along it. </p>

</div>
</div>
<a class="anchor" id="ad990738da810df3076f05130abc9d8e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MeshEntity::_naturalTexUnits[<a class="el" href="class_mesh_entity.html#a770df881e27ba52fa9382b055fed91d4a77ba9a9f666dd71c0595921f0848ac0c">NUM_TEX_AXES</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of grid units that would constitute a "natural" scale along each texture axis, using the mesh's current texture. </p>
<p>Radiant's natural scale is 1/2 as many grid units as there are texture pixels. </p>

</div>
</div>
<a class="anchor" id="a0e4ce970735d8cb8e0bb5757e1a060bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * MeshEntity::_warningSliceInfscaleFormatString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"></div>
<div class="line">   { WARNING_ROW_INFSCALE, WARNING_COL_INFSCALE }</div>
</div><!-- fragment -->
<p>Message format strings for warning that a scale value is infinite and cannot be transferred to the Set S/T Scale dialog. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_mesh_entity_8h_source.html">MeshEntity.h</a></li>
<li><a class="el" href="_mesh_entity_8cpp.html">MeshEntity.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_mesh_entity.html">MeshEntity</a></li>
    <li class="footer">Generated on Mon Jul 30 2012 17:22:17 for MeshTex by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>
